// Generated by CoffeeScript 1.7.1
var $gateSize, $halfGateSize, $socketPadding, $socketSize, AndGate, BufferGate, Collectable, Device, Gate, IODevice, Lightbulb, NandGate, NorGate, NotGate, OrGate, Socket, Tool, Toolbox, Wire, XnorGate, XorGate, distance, distanceSquared, sendBoolex,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collectable = (function() {
  function Collectable(klass) {
    this.klass = klass;
    this.id = Collectable.createUuid();
    this.klass || (this.klass = this.constructor);
    this.klass.add(this);
  }

  Collectable.prototype.destroy = function() {
    return this.klass.remove(this);
  };

  Collectable.add = function(obj) {
    if (this.all == null) {
      this.all = [];
      this.hash = {};
    }
    this.all.push(obj);
    return this.hash[obj.id] = obj;
  };

  Collectable.collection = function() {
    return this.all;
  };

  Collectable.remove = function(obj) {
    if (this.all != null) {
      this.hash[obj.id] = null;
      return this.all = $.grep(this.all, function(obj2) {
        return obj2.id !== obj.id;
      });
    }
  };

  Collectable.find = function(id) {
    return this.hash[id];
  };

  Collectable.createUuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  return Collectable;

})();

Device = (function(_super) {
  __extends(Device, _super);

  function Device(numIns, numOuts, klass) {
    this.numIns = numIns;
    this.numOuts = numOuts;
    this.drag = __bind(this.drag, this);
    this.startDrag = __bind(this.startDrag, this);
    this.initSockets();
    this.initGraphics();
    this.initEvents();
    Device.__super__.constructor.call(this, klass);
  }

  Device.prototype.initSockets = function() {
    var i;
    this.inputSockets = this.outputSockets = [];
    if (this.numIns > 0) {
      this.inputSockets = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = this.numIns; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(new Socket(this, i, 'in'));
        }
        return _results;
      }).call(this);
    }
    if (this.numOuts > 0) {
      return this.outputSockets = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = this.numOuts; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(new Socket(this, i, 'out'));
        }
        return _results;
      }).call(this);
    }
  };

  Device.prototype.initGraphics = function() {
    var i, socket, _i, _j, _len, _len1, _ref, _ref1;
    this.graphics = new createjs.Container();
    this.box = this.constructor.createGraphics();
    this.graphics.addChild(this.box);
    _ref = this.inputSockets;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      socket = _ref[i];
      socket.graphics.x = -$socketPadding;
      socket.graphics.y = ($gateSize / (this.numIns + 1)) * (i + 1) - $halfGateSize;
      this.graphics.addChild(socket.graphics);
    }
    _ref1 = this.outputSockets;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      socket = _ref1[i];
      socket.graphics.x = $socketPadding;
      socket.graphics.y = ($gateSize / (this.numOuts + 1)) * (i + 1) - $halfGateSize;
      this.graphics.addChild(socket.graphics);
    }
    return window.boolexStage.addChild(this.graphics);
  };

  Device.prototype.initEvents = function() {
    var self;
    self = this;
    this.box.on("mousedown", function(e) {
      return this.offset = {
        x: self.graphics.x - e.stageX,
        y: self.graphics.y - e.stageY
      };
    });
    return this.box.on("pressmove", this.drag);
  };

  Device.prototype.inputDevices = function() {
    var inputSocket;
    return [
      (function() {
        var _i, _len, _ref, _results;
        if (inputSocket.wires.length) {
          _ref = this.inputSockets;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            inputSocket = _ref[_i];
            _results.push(inputSocket.wires[0].fromSocket);
          }
          return _results;
        }
      }).call(this)
    ];
  };

  Device.prototype.startDrag = function(e) {
    this.graphics.offset = {
      x: this.graphics.x - e.stageX,
      y: this.graphics.y - e.stageY
    };
    return e.on('mousemove', this.drag);
  };

  Device.prototype.drag = function(e) {
    var socket, wire, _i, _len, _ref, _results;
    this.graphics.x = e.stageX + this.graphics.offset.x;
    this.graphics.y = e.stageY + this.graphics.offset.y;
    _ref = this.inputSockets.concat(this.outputSockets);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;
        _ref1 = socket.wires;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          wire = _ref1[_j];
          _results1.push(wire.redraw());
        }
        return _results1;
      })());
    }
    return _results;
  };

  Device.createGraphics = function() {
    var bounds, box, container, text;
    container = new createjs.Container();
    box = new createjs.Shape();
    box.graphics.beginFill('black').drawRect(0, 0, $gateSize, $gateSize);
    box.graphics.beginFill('white').drawRect(2, 2, $gateSize - 4, $gateSize - 4);
    box.x = box.y = -$halfGateSize;
    container.addChild(box);
    text = new createjs.Text(this.displayName, '14px Helvetica');
    bounds = text.getBounds();
    text.x = -bounds.width / 2;
    text.y = -bounds.height / 2;
    container.addChild(text);
    return container;
  };

  return Device;

})(Collectable);

Gate = (function(_super) {
  __extends(Gate, _super);

  function Gate(numIns, numOuts) {
    this.numIns = numIns;
    this.numOuts = numOuts;
    Gate.__super__.constructor.call(this, this.numIns, this.numOuts, Gate);
  }

  Gate.registerType = function(gateClass) {
    return this.types.push(gateClass);
  };

  Gate.createGraphics = function() {
    var bitmap, box, container;
    container = new createjs.Container();
    bitmap = new createjs.Bitmap(this.bitmap);
    bitmap.x = -$gateSize * 0.5;
    bitmap.y = -$gateSize * 0.5;
    container.addChild(bitmap);
    box = new createjs.Shape();
    box.graphics.beginFill(createjs.Graphics.getRGB(255, 0, 0));
    box.graphics.rect(0, 0, $gateSize, $gateSize);
    box.x = -$gateSize * 0.5;
    box.y = -$gateSize * 0.5;
    container.hitArea = box;
    return container;
  };

  Gate.prototype.createDSL = function() {};

  Gate.createDSL = function() {
    var dsl, gate, inputs, outs, s, socket, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    inputs = [];
    if (Gate.all == null) {
      return "circuit main()\nend";
    }
    _ref = Gate.all;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      gate = _ref[_i];
      _ref1 = gate.inputSockets;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        socket = _ref1[_j];
        if (socket.wires.length < 1) {
          inputs.push(socket);
        }
      }
    }
    dsl = "circuit main(" + ([
      (function() {
        var _k, _len2, _results;
        _results = [];
        for (_k = 0, _len2 = inputs.length; _k < _len2; _k++) {
          s = inputs[_k];
          _results.push(s.name);
        }
        return _results;
      })()
    ].join(', ')) + ")\n";
    _ref2 = this.all;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      gate = _ref2[_k];
      dsl += '  ' + gate.createDSL() + '\n';
    }
    outs = $.grep(Socket.all, function(socket) {
      return socket.type === 'out' && !socket.connectedToGate();
    });
    dsl += '  out ' + [
      (function() {
        var _l, _len3, _results;
        _results = [];
        for (_l = 0, _len3 = outs.length; _l < _len3; _l++) {
          socket = outs[_l];
          _results.push(socket.name);
        }
        return _results;
      })()
    ].join(', ') + '\n';
    dsl += 'end';
    return dsl;
  };

  Gate.displayName = 'GATE';

  Gate.bitmap = "";

  Gate.types = [];

  return Gate;

})(Device);

AndGate = (function(_super) {
  __extends(AndGate, _super);

  function AndGate() {
    AndGate.__super__.constructor.call(this, 2, 1);
  }

  AndGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " * " + in2.name;
  };

  AndGate.displayName = 'AND';

  AndGate.bitmap = '/assets/images/and_gate.png';

  return AndGate;

})(Gate);

OrGate = (function(_super) {
  __extends(OrGate, _super);

  function OrGate() {
    OrGate.__super__.constructor.call(this, 2, 1);
  }

  OrGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " + " + in2.name;
  };

  OrGate.displayName = 'OR';

  OrGate.bitmap = '/assets/images/or_gate.png';

  return OrGate;

})(Gate);

NotGate = (function(_super) {
  __extends(NotGate, _super);

  function NotGate() {
    NotGate.__super__.constructor.call(this, 1, 1);
  }

  NotGate.prototype.createDSL = function() {
    var in1, out;
    in1 = this.inputSockets[0];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + "'";
  };

  NotGate.displayName = 'NOT';

  NotGate.bitmap = '/assets/images/not_gate.png';

  return NotGate;

})(Gate);

XorGate = (function(_super) {
  __extends(XorGate, _super);

  function XorGate() {
    XorGate.__super__.constructor.call(this, 2, 1);
  }

  XorGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " ^ " + in2.name;
  };

  XorGate.displayName = 'XOR';

  XorGate.bitmap = '/assets/images/xor_gate.png';

  return XorGate;

})(Gate);

NandGate = (function(_super) {
  __extends(NandGate, _super);

  function NandGate() {
    NandGate.__super__.constructor.call(this, 2, 1);
  }

  NandGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " nand " + in2.name;
  };

  NandGate.displayName = 'NAND';

  NandGate.bitmap = '/assets/images/nand_gate.png';

  return NandGate;

})(Gate);

NorGate = (function(_super) {
  __extends(NorGate, _super);

  function NorGate() {
    NorGate.__super__.constructor.call(this, 2, 1);
  }

  NorGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " nor " + in2.name;
  };

  NorGate.displayName = 'NOR';

  NorGate.bitmap = '/assets/images/nor_gate.png';

  return NorGate;

})(Gate);

XnorGate = (function(_super) {
  __extends(XnorGate, _super);

  function XnorGate() {
    XnorGate.__super__.constructor.call(this, 2, 1);
  }

  XnorGate.prototype.createDSL = function() {
    var in1, in2, out;
    in1 = this.inputSockets[0];
    in2 = this.inputSockets[1];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name + " xnor " + in2.name;
  };

  XnorGate.displayName = 'XNOR';

  XnorGate.bitmap = '/assets/images/xnor_gate.png';

  return XnorGate;

})(Gate);

BufferGate = (function(_super) {
  __extends(BufferGate, _super);

  function BufferGate() {
    BufferGate.__super__.constructor.call(this, 1, 1);
  }

  BufferGate.prototype.createDSL = function() {
    var in1, out;
    in1 = this.inputSockets[0];
    out = this.outputSockets[0];
    return "" + out.name + " = " + in1.name;
  };

  BufferGate.displayName = 'BUFF';

  BufferGate.bitmap = '/assets/images/buffer_gate.png';

  return BufferGate;

})(Gate);

Gate.registerType(AndGate);

Gate.registerType(OrGate);

Gate.registerType(NotGate);

Gate.registerType(XorGate);

Gate.registerType(NandGate);

Gate.registerType(NorGate);

Gate.registerType(XnorGate);

Gate.registerType(BufferGate);

IODevice = (function(_super) {
  __extends(IODevice, _super);

  function IODevice(numIns, numOuts) {
    $(window).on('current', function(e) {
      var device, devices, _i, _len, _results;
      devices = IODevice.all;
      _results = [];
      for (_i = 0, _len = devices.length; _i < _len; _i++) {
        device = devices[_i];
        _results.push(device.draw());
      }
      return _results;
    });
    IODevice.__super__.constructor.call(this, numIns, numOuts, IODevice);
  }

  IODevice.prototype.draw = function() {};

  IODevice.registerType = function(ioDeviceClass) {
    return this.types.push(ioDeviceClass);
  };

  IODevice.displayName = 'IO';

  IODevice.types = [];

  return IODevice;

})(Device);

Lightbulb = (function(_super) {
  __extends(Lightbulb, _super);

  function Lightbulb() {
    this.bitmap = Lightbulb.__super__.constructor.call(this, 1, 0);
  }

  Lightbulb.createGraphics = function() {
    var bitmapOff, box, container;
    container = new createjs.Container();
    bitmapOff = new createjs.Bitmap(this.bitmapOff);
    bitmapOff.x = -$gateSize * 0.5;
    bitmapOff.y = -$gateSize * 0.5;
    container.addChild(bitmapOff);
    box = new createjs.Shape();
    box.graphics.beginFill(createjs.Graphics.getRGB(255, 0, 0));
    box.graphics.rect(0, 0, $gateSize, $gateSize);
    box.x = -$gateSize * 0.5;
    box.y = -$gateSize * 0.5;
    container.hitArea = box;
    return container;
  };

  Lightbulb.prototype.draw = function() {
    if (this.inputSocket[0].on) {
      if (!this.graphics.contains(this.light)) {
        return this.graphics.addChild(this.light);
      }
    } else {
      return this.graphics.removeChild(this.light);
    }
  };

  Lightbulb.displayName = 'BULB';

  Lightbulb.bitmapOff = '/assets/images/Lightbulb_off.png';

  Lightbulb.bitmapOn = '/assets/images/Lightbulb_on.png';

  return Lightbulb;

})(IODevice);

IODevice.registerType(Lightbulb);

$(document).ready(function() {
  var canvas, toolbox;
  canvas = $('#boolex-stage');
  canvas[0].width = canvas.parent().innerWidth();
  canvas[0].height = $(window).innerHeight();
  canvas.mousedown(function(e) {
    return e.preventDefault();
  });
  window.boolexStage = new createjs.Stage("boolex-stage");
  toolbox = new Toolbox();
  createjs.Ticker.on('tick', function() {
    return window.boolexStage.update();
  });
  $(window).on('refreshDSL', function() {
    return console.log(Gate.createDSL());
  });
  return $('#start-stop-button').click(function() {
    var $this;
    $this = $(this);
    if ($this.data('running') != null) {
      $this.removeClass('btn-danger').addClass('btn-primary').text('Start');
      return $this.data('running', null);
    } else {
      sendBoolex();
      $this.removeClass('btn-primary').addClass('btn-danger').text('Stop');
      return $this.data('running', true);
    }
  });
});

$gateSize = 40;

$halfGateSize = $gateSize / 2;

$socketSize = 4;

$socketPadding = $halfGateSize + 4;

distanceSquared = function(x1, y1, x2, y2) {
  var dx, dy;
  dx = x2 - x1;
  dy = y2 - y1;
  return dx * dx + dy * dy;
};

distance = function(x1, y1, x2, y2) {
  return Math.sqrt(distanceSquared(x1, y1, x2, y2));
};

window.cometMessage = function(message) {
  return console.log("Event received: " + message);
};

window.echo = function(message) {
  return $('#echoer').attr('src', "/echo/" + (encodeURIComponent(message)));
};

sendBoolex = function() {
  var connection, dsl;
  dsl = Gate.createDSL();
  connection = new WebSocket("ws://localhost:9000/boolex?dsl=" + (encodeURIComponent(dsl)), ['soap', 'xmpp']);
  connection.onopen = function(msg) {
    return console.log(msg);
  };
  connection.onerror = function(error) {
    return console.log('WebSocket Error ' + error);
  };
  return connection.onmessage = function(e) {
    return console.log('Server: ' + e.data);
  };
};

Socket = (function(_super) {
  __extends(Socket, _super);

  function Socket(device, index, type) {
    this.device = device;
    this.index = index;
    this.type = type;
    this.initGraphics();
    this.initEvents();
    this.wires = [];
    this.name = Socket.randomName();
    Socket.__super__.constructor.call(this);
  }

  Socket.prototype.initGraphics = function() {
    this.graphics = new createjs.Container();
    this.circle = new createjs.Shape();
    this.circle.graphics.beginFill('black').drawCircle(0, 0, $socketSize);
    return this.graphics.addChild(this.circle);
  };

  Socket.prototype.initEvents = function() {
    return this.graphics.on('mousedown', (function(_this) {
      return function(e) {
        var wire;
        if (_this.type === 'out') {
          wire = new Wire(_this, null);
        } else {
          wire = new Wire(null, _this);
        }
        return wire.startDrag(e);
      };
    })(this));
  };

  Socket.prototype.connectedSockets = function() {
    var getter, wire, _i, _len, _ref, _results;
    getter = this.type === 'in' ? 'fromSocket' : 'toSocket';
    _ref = this.wires;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      wire = _ref[_i];
      if (wire[getter] != null) {
        _results.push(wire[getter]);
      }
    }
    return _results;
  };

  Socket.prototype.connectedToGate = function() {
    var socket, _i, _len, _ref;
    _ref = this.connectedSockets();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      if (socket.device instanceof Gate) {
        return true;
      }
    }
    return false;
  };

  Socket.prototype.x = function() {
    return this.graphics.localToGlobal(0, 0).x;
  };

  Socket.prototype.y = function() {
    return this.graphics.localToGlobal(0, 0).y;
  };

  Socket.randomName = function() {
    var i, name, possible, _i;
    possible = 'abcdefghijklmnopqrstuvwxyz';
    name = '';
    for (i = _i = 0; _i <= 4; i = ++_i) {
      name += possible[Math.floor(Math.random() * 26)];
    }
    return name;
  };

  Socket.connect = function(fromSocket, toSocket, wire) {
    fromSocket.wires.push(wire);
    toSocket.wires.push(wire);
    return toSocket.name = fromSocket.name;
  };

  return Socket;

})(Collectable);

Toolbox = (function() {
  function Toolbox() {
    var device, i, tool, _i, _len, _ref;
    this.devices = Gate.types.concat(IODevice.types);
    this.tools = (function() {
      var _i, _len, _ref, _results;
      _ref = this.devices;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        device = _ref[i];
        _results.push(new Tool(device, i));
      }
      return _results;
    }).call(this);
    this.graphics = new createjs.Container();
    _ref = this.tools;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tool = _ref[_i];
      this.graphics.addChild(tool.graphics);
    }
    this.graphics.x = $halfGateSize;
    this.graphics.y = $halfGateSize;
    window.boolexStage.addChild(this.graphics);
    window.boolexStage.update();
  }

  Toolbox.padding = 5;

  return Toolbox;

})();

Tool = (function() {
  function Tool(deviceClass, index) {
    this.deviceClass = deviceClass;
    this.index = index;
    this.graphics = new createjs.Container();
    this.graphics.addChild(deviceClass.createGraphics());
    this.graphics.y = this.index * ($gateSize + Toolbox.padding);
    this.graphics.on('mousedown', function(e) {
      var newGate, _ref;
      newGate = new deviceClass();
      _ref = (function(coord) {
        return [coord.x, coord.y];
      })(this.localToGlobal(0, 0)), newGate.graphics.x = _ref[0], newGate.graphics.y = _ref[1];
      return newGate.startDrag(e);
    });
  }

  return Tool;

})();

Wire = (function(_super) {
  __extends(Wire, _super);

  function Wire(fromSocket, toSocket) {
    this.fromSocket = fromSocket;
    this.toSocket = toSocket;
    this.stopDrag = __bind(this.stopDrag, this);
    this.drag = __bind(this.drag, this);
    this.startDrag = __bind(this.startDrag, this);
    this.initGraphics();
    this.target = null;
    Wire.__super__.constructor.call(this);
    if ((this.fromSocket != null) && (this.toSocket != null)) {
      this.fromSocket.wires.push(this);
      this.toSocket.wires.push(this);
    } else if (this.fromSocket != null) {
      this.startSocket = this.fromSocket;
      this.endSocket = 'toSocket';
    } else if (this.toSocket != null) {
      this.startSocket = this.toSocket;
      this.endSocket = 'fromSocket';
    }
  }

  Wire.prototype.initGraphics = function() {
    this.graphics = new createjs.Container();
    this.line = new createjs.Shape();
    this.graphics.addChild(this.line);
    return window.boolexStage.addChild(this.graphics);
  };

  Wire.prototype.startDrag = function(e) {
    var startSocketPos;
    this.line.graphics.clear();
    startSocketPos = this.startSocket.graphics.localToGlobal(0, 0);
    this.drawTo(startSocketPos.x, startSocketPos.y, e.stageX, e.stageY);
    e.on('mousemove', this.drag);
    return e.on('mouseup', this.stopDrag);
  };

  Wire.prototype.drag = function(e) {
    var socket, startSocketPos, _i, _len, _ref, _results;
    startSocketPos = this.startSocket.graphics.localToGlobal(0, 0);
    this.line.graphics.moveTo(startSocketPos.x, startSocketPos.y);
    if (this.target != null) {
      this.drawTo(startSocketPos.x, startSocketPos.y, this.target.x(), this.target.y());
    } else {
      this.drawTo(startSocketPos.x, startSocketPos.y, e.stageX, e.stageY);
    }
    this.target = null;
    _ref = Socket.all;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      socket = _ref[_i];
      if (distance(socket.x(), socket.y(), e.stageX, e.stageY) < $socketSize * 2) {
        if (socket.type !== this.startSocket.type) {
          if (!(socket.type === 'in' && socket.wires.length)) {
            this.target = socket;
            break;
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Wire.prototype.drawTo = function(x1, y1, x2, y2) {
    this.line.graphics.clear();
    this.line.graphics.beginStroke('black');
    this.line.graphics.moveTo(x1, y1);
    this.line.graphics.lineTo((x2 + x1) * 0.5, y1);
    this.line.graphics.lineTo((x2 + x1) * 0.5, y2);
    return this.line.graphics.lineTo(x2, y2);
  };

  Wire.prototype.stopDrag = function(e) {
    if (this.target) {
      this[this.endSocket] = this.target;
      Socket.connect(this.fromSocket, this.toSocket, this);
      return $(window).trigger('refreshDSL');
    } else {
      return this.destroy();
    }
  };

  Wire.prototype.redraw = function() {
    var fromSocketPos, toSocketPos;
    fromSocketPos = this.fromSocket.graphics.localToGlobal(0, 0);
    toSocketPos = this.toSocket.graphics.localToGlobal(0, 0);
    return this.drawTo(fromSocketPos.x, fromSocketPos.y, toSocketPos.x, toSocketPos.y);
  };

  Wire.prototype.destroy = function() {
    window.boolexStage.removeChild(this.graphics);
    if (this.fromSocket != null) {
      this.fromSocket.wires = $.grep(this.fromSocket.wires, function(wire) {
        return wire.id !== this.id;
      });
    }
    if (this.toSocket != null) {
      this.toSocket.wires = $.grep(this.toSocket.wires, function(wire) {
        return wire.id !== this.id;
      });
    }
    return Wire.__super__.destroy.call(this);
  };

  return Wire;

})(Collectable);
